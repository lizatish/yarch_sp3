# Подзадание 1.1: Анализ и планирование

## Context diagram - Диаграмма контекста

Данная часть описывает монолитную систему как есть, то есть AS IS

### 1. Изучение функциональности монолитного приложения

Приложение состоит из нескольких составляющих:

1) Датчик измерения температуры

Функциональные возможности:

- Измерять текущую температуру и показывать результат
- Выключаться
- Включаться

2) Система управления отоплением

Функциональные возможности:

- Задавать температуру на умное устройство отопления
- Получать данные о текущей температуре с датчика измерения температуры

2) Умное устройство отопления

Функциональные возможности:

- Задавать новую температура
- Поддерживать заданную температуру
- Выключаться
- Включаться

С системой взаимодействует мастер и пользователь (владелец дома). Процесс следующий:

1) Пользователь покупает умное устройство
2) Пользователь вызывает мастера для подключения умного устройства
3) Мастер приезжает на дом к пользователю, настраивает умное устройство, заносит идентификатор умного устройства вручную
   в БД системы управления отоплением.
4) Пользователь может через графический интерфейс/мобильный телефон задавать команды умному устройству
5) Команды поступают на систему управления отоплением, расположенной в компании.
6) Система управления отоплением отправляет запрос на систему датчика
7) Датчик принимает управляющее воздействие от сервера и изменяет свое состояние

Система не автоматизированна и сложно масштабируема. Любой новый датчик должен быть подключен вручную мастером.

### 2. Анализ архитектуры монолитного приложения

Приложение написано на Java, развернуто в Docker. Система монолитная, слабо масштабируемая. В качестве БД использована
PostgresDB.

### 3. Определение доменов и границ доменов

Домен 1 - Датчик температуры
Домен 2 - Умное устройство отопления
Домен 3 - Управление устройствами и датчиками

### 4. Визуализация контекста системы

Решение представлено в виде диаграммы контекста как состояние системы AS IS, файл находится по
пути: [Context.puml](docs%2F%D1%814%2FContext.puml)

# Подзадание 1.2: Архитектура микросервисов

В данном задании реализованы две С4-диаграммы (контекста и компонентов). Кроме этого монолитный код разделен на 4
микросервиса:

- сервис биллинга [billing-service](smart-home-microservices%2Fbilling-service)
- сервис нотификации [notification-service](smart-home-microservices%2Fnotification-service)
- сервис управления датчиками температуры [heat-sensor-service](smart-home-microservices%2Fheat-sensor-service)
- сервис управления умным устройством
  отопления [heating-system-service](smart-home-microservices%2Fheating-system-service)

Реализация находится в новом каталоге [smart-home-microservices](smart-home-microservices)
Предполагается, что существует контейнер с API-gateway на nginx (в рамках задания не реализовано). У каждого
микросервиса существует своя БД PostgreSQL (в рамках задания ре реализовано).

Ввиду особенностей реализации системы предполагается, что в Postgres будет реализована репликация по паттерну Read
Replica, так как множество устройств будут читать БД, в то время как изменения БД будут происходить не так часто. Если
какой-либо микросервис не будет справляться с нагрузкой, то он может быть отмасштабирован на уровне приложения, а также
на уровне БД через шардирование (с использованием Citus). В случае, если узким местом станет API Gateway, его также
можно отмасштабировать, добавив несколько инстансов.

Все взаимодействия между пользователем и системой реализовано через API. Причина этого в том, что система не
предполагает таких нагрузок от пользователей, где API не будет выдерживать. В случае, если какой-то сервис не будет
справляться с нагрузкой, он может быть отмасштабирован как на уровне приложения с равномерным распределением запросов
через API Gateway, либо отмасштабирован на стороне БД через шардирование.

## Container diagram - Диаграмма контейнеров [Container.puml](docs%2F%D1%814%2FContainer.puml)

На диаграмме контейнеров отображено несколько контуров:

1) Контур дома пользователя. В нем находится пользователь (владелец дома), а также все умные устройства пользователя
2) Контур системы удаленного управления умными устройствами. В нем находятся все микросервисы и контейнеры, необходимые
   для работы системы.
3) Внешняя система авторизации Keycloack

Взаимодействие пользователя с системой предполагается следующим образом:

1) Пользователь покупает умное устройство. Внутри устройство представляет собой умную систему, которая способна
   принимать сигналы по API, и непосредственно физическое устройство.
2) Пользователь регистрируется (или авторизуется, если зарегистрирован) в системе управления умными устройства через
   ПК или телефон
3) Пользователь подключает умное устройство, указав идентификационный номер устройства и тип устройства через ПК или
   телефон
4) Все запросы от пользователя принимаются API Gateway, который по урлу перенаправляет запросы на соответствующие
   сервисы
5) Запросы, связанные с регистрацией и авторизацией отправляются в Keycloak
6) Запросы, связанные с конкретным типом устройства отправлются на соответствующий микросервис. Пока таких микросервисов
   два: микросервис по работе с датчиками температуры и микросервис для работы с отопительными системами. В случае, если
   компания разработает другие новые умные устройства, то для каждого из них будет создан отдельный микросервис со своей
   БД для хранения данных по устройствам, а также будут обновлены настройки API Gateway для маршрутизации по новым URL.
   Кроме того, будет обновлен внешний вид приложения системы для ПК и телефонов, чтобы у пользователя была возможность
   подключить умное устройство нового типа.
7) После того, как пользователь зарегистрировал устройство, ему нужно внести небольшую оплату для активации устройства.
   Для этого пользователю будет сформирован QR-код в разделе активации умных устройств, по которому необходимо внести
   указанную сумму через приложение банка.
8) Все операции с оплатой поступают на сервис биллинга
9) После того, как устройство подключено, устройство будет в течении определенного времени опрашивать сервер на наличие
   обновлений. Таким образом также будет гарантироваться жизнеспособность устройства. Каждый микросервис, отвечающий за
   работу устройств, будет время от времени проверять время последнего пинга устройства и в случае, если пингов давно не
   было, сможет отправить пользователю уведомление о том, что устройство потенциально может быть сломано (например,
   потому что разряжено).
10) Пользователь может отправить команду на устройство. В этом случае команда поступит на API Gateway, перенаправится на
    соответствующий устройству сервис. Сервис обработает команды, внесет изменения в БД. Устройство в следующий момент
    своего пинга прочитает изменения в БД и изменит свое состояние.
11) У системы есть возможность отправлять сообщения пользователю. Этим занимается сервис нотификации. Уведомления в
    простейшем варианте отправляются на email, но также могут быть продублированы в качестве всплывающих уведомлений в
    приложении на телефоне.

## Component diagrams - Диаграмма компонентов [Component.puml](docs%2F%D1%814%2FComponent.puml)

Для диаграммы компонентов был выбран сервис работы с датчиками измерения температуры. Предполагается, что все
микросервисы будут реализованы сходим образом, а именно будут присутствовать:

- контроллер, принимающий команды через API
- сервисный слой, реализующий основную бизнес-логику
- слой репозитория, который отвечает за взаимодействие c БД
- внешняя база данных (PostgreSQL)

# Подзадание 1.3: ER-диаграмма

ER диаграмма, описывающая сущности системы представлена по пути [instances.puml](docs%2Fer%2Finstances.puml)

Определение сущностей:

1) Сущность "Пользователь" - владелец дома. Обладает уникальным идентификатором, выданным при регистрации, который
   запечатывается в токен. Обладает личной информацией (имя, дата регистрации), а также знанием о всех подключенных
   устройствах (их типом и уникальным идентификатором)
2) Сущность "Устройство" - устройство умного дома. Принадлежит пользователю, обладает уникальным идентификатором и типом
   из существующих типов
3) Сущность "Умная система отопления" - единица умной системы отопления. Обладает информацией о текущей выставленной
   температуре, последнем обновлении.
4) Сущность "Датчик температуры"  - единица измерения температуры. Обладает информацией о текущей измеренной температуре
   и о последнем обновлении
5) Сущность "Платеж" - совершенный платеж пользователя при активации устройства. Включает в себя дату проведения и сумму
   операции, идентификатор пользователя, тип и идентификатор активированного устройства
6) Сущность "Уведомление" - уведомление пользователю, включает в себя почту пользователя, текст сообщения, дату
   отправки, тип уведомления
7) Сущность "Тип устройства" - перечисляемый тип, содержащий все поддерживаемые типы устройств на данный момент
   8Сущность "Тип уведомления" - перечисляемый тип, содержащий все поддерживаемые типы уведомлений на данный момент

Связи между атрибутами:

1) У пользователя может быть одно или несколько устройств
2) Любое устройство может быть строго одного типа
3) У пользователя может быть одно или несколько платежей
4) У пользователя может быть одно или несколько уведомлений
5) Каждое уведомление включает строго один тип
6) Каждый платеж включает строго один тип устройства
7) Каждое устройство включает строго один тип устройства
8) Датчик температуры имеет строго один тип устройства
9) Умная система отопления имеет строго один тип устройства

# Подзадание 1.4: Создание и документирование API

Документация для каждого микросервиса находится в файле `openapi.yaml`

1) Сервис биллинга [openapi.yaml](smart-home-microservices%2Fbilling-service%2Fsrc%2Fopenapi.yaml)
2) Сервис управления датчиками
   температуры [openapi.yaml](smart-home-microservices%2Fheat-sensor-service%2Fsrc%2Fopenapi.yaml)
3) Сервис управления отопительными
   системами [openapi.yaml](smart-home-microservices%2Fheating-system-service%2Fsrc%2Fopenapi.yaml)
4) Сервис нотификации [openapi.yaml](smart-home-microservices%2Fnotification-service%2Fsrc%2Fopenapi.yaml)

Опишем основные URL.

### Сервис биллинга:

1) `POST /api/v1/payments` - Произвести оплату подключения устройства

Параметры query:

- `token: str` - Токен для доступа к api
- `PayeeINN: int` - ИНН юр.лица или ИП
- `Name: str` - Наименование юр.лица или ИП
- `BIC: int` - БИК банка
- `PersonalAcc: int` - Расчётный счёт
- `lastName: int` - ФИО плательщика
- `Purpose: str` - Назначение
- `Sum: int` - Сумма рублей
- `sumKop: int` - Сумма копеек

Формат ответа:
Статусы:

- `200 OK` - Все ок
- `400 BAD REQUEST` - Платеж не был совершен по какой-либо причине

Тело ответа:

- `status: str` - Статус операции
- `paymentId: uuid` - Идентификатор операции

2) `GET /api/v1/payments/{paymentId}`- Получить статус операции

Формат ответа:
Статусы:

- `200 OK` - Все ок
- `404 NOT FOUND` - Платеж не найден

Тело ответа:

- `status: str` - Статус операции
- `paymentId: uuid` - Идентификатор операции

### Сервис управления отопительными системами

1) `GET /api/v1/smart-heating-system/{id}` - Получить данные об устройстве

Параметр запроса:

- `id: uuid` - Идентификатор устройства

Формат ответа:
Статусы:

- `200 OK` - Все ок
- `404 NOT FOUND` - Устройство не найдено

Тело ответа:

- `id: uuid` - Идентификатор устройства
- `lastTemperature: double` - Текущая температура
- `lastUpdated: datetime` - Последнее обновление

2) `POST /api/v1/smart-heating-system` - Зарегистрировать устройство

Тело запроса:

- `userId: uuid` - Идентификатор пользователя
- `deviceId: uuid` - Идентификатор устройства

Формат ответа:
Статусы:

- `200 OK` - Все ок
- `409 CONFLICT` - Устройство было зарегистрировано ранее

3) `PUT /api/v1/smart-heating-system/{id}` - Дать команду на устройство

Тело запроса:

- `userId: uuid` - Идентификатор пользователя
- `deviceId: uuid` - Идентификатор устройства

Формат ответа:
Статусы:

- `200 OK` - все ок
- `404 NOT FOUND` - устройство не найдено

- Тело ответа:

- `id: uuid` - идентификатор устройства
- `lastTemperature: double` - текущая температура
- `lastUpdated: datetime` - последнее обновление

### Сервис управления датчиками температуры

1) `GET /api/v1/heating-sensor/{id}` - Получить данные об устройстве

Параметр запроса:

- `id: uuid` - Идентификатор устройства

Формат ответа:
Статусы:

- `200 OK` - Все ок
- `404 NOT FOUND` - Устройство не найдено

Тело ответа:

- `id: uuid` - Идентификатор устройства
- `currentTemperature: double` - Текущая температура
- `lastUpdated: datetime` - Последнее обновление

2) `POST /api/v1/heating-sensor` - Зарегистрировать устройство

Тело запроса:

- `userId: uuid` - Идентификатор пользователя
- `deviceId: uuid` - Идентификатор устройства

Формат ответа:
Статусы:

- `200 OK` - Все ок
- `409 CONFLICT` - Устройство было зарегистрировано ранее

3) `PUT /api/v1/heating-sensor/{id}` - Сохранить в систему информацию о текущей температуре

Тело запроса:

- `userId: uuid` - Идентификатор пользователя
- `deviceId: uuid` - Идентификатор устройства
- `currentTemperature: double` - Текущая измеренная температура

Формат ответа:
Статусы:

- `200 OK` - все ок
- `404 NOT FOUND` - устройство не найдено

- Тело ответа:

- `id: uuid` - идентификатор устройства
- `currentTemperature: double` - текущая температура
- `lastUpdated: datetime` - последнее обновление

### Сервис нотификации:

1) `POST /api/v1/notifications` - Добавить новое уведомление

Тело запроса:

- `userId: uuid` - Идентификатор пользователя
- `email: str` - Почта пользователя
- `type: str` - Тип уведомления

Формат ответа:
Статусы:

- `200 OK` - Все ок

### Сервис авторизации:

Предполагается, что авторизация реализована через OAUTH-протокол со сторонними сервисами (Google, VK и т п).
API-Gateway перенаправляет в Keycloak запросы вида (пример условен и будет меняться в зависимости от сервиса, но принцип
схож):
https://account.box.com/api/oauth2/authorize?client_id={client_id}&redirect_uri={redirect_url}&response_type=code
, где

- `account.box.com` - Доменное имя сервиса, через который будет проходить авторизация;
- `client_id` - Идентификатор клиента приложения, полученный заранее от сервиса
- `redirect_url` - Урл, на который вернется ответ после успешной авторизации пользователя через сторонний сервис. Логика
  внутри этого обработчика должна вычленять дополнительно выданный код из строки запроса, отправлять запрос на сервис,
  через который логинится пользователь, получать access_token, который будет выдан пользователю и подхвачен во всех
  дальнейших заголовках.

Сервис авторизации также будет хранить информацию о всех зарегистрированных в системе пользователях в своей БД. Он также
будет иметь возможность проверять авторизацию пользователя по токену. Этой функциональностью будут пользоваться
микросервисы, чтобы проверить токен пользователя при доступе на эндпоинт.
Это будет выглядеть как запрос вида:

- `GET /api/v1/users/check/token`

Где в заголовке будет передан указанный токен

И форматов ответа:

- `200 OK` - Токен валиден
- `403 FORBIDDEN` - Доступ запрещен

# Необязательные задания 2 и 3 не были реализованы в рамках данного проекта

# Базовая настройка

## Запуск minikube

[Инструкция по установке](https://minikube.sigs.k8s.io/docs/start/)

```bash
minikube start
```

## Добавление токена авторизации GitHub

[Получение токена](https://github.com/settings/tokens/new)

```bash
kubectl create secret docker-registry ghcr --docker-server=https://ghcr.io --docker-username=<github_username> --docker-password=<github_token> -n default
```

## Установка API GW kusk

[Install Kusk CLI](https://docs.kusk.io/getting-started/install-kusk-cli)

```bash
kusk cluster install
```

## Настройка terraform

[Установите Terraform](https://yandex.cloud/ru/docs/tutorials/infrastructure-management/terraform-quickstart#install-terraform)

Создайте файл ~/.terraformrc

```hcl
provider_installation {
  network_mirror {
    url = "https://terraform-mirror.yandexcloud.net/"
    include = ["registry.terraform.io/*/*"]
  }
  direct {
    exclude = ["registry.terraform.io/*/*"]
  }
}
```

## Применяем terraform конфигурацию

```bash
cd terraform
terraform apply
```

## Настройка API GW

```bash
kusk deploy -i api.yaml
```

## Проверяем работоспособность

```bash
kubectl port-forward svc/kusk-gateway-envoy-fleet -n kusk-system 8080:80
curl localhost:8080/hello
```

## Delete minikube

```bash
minikube delete
```
